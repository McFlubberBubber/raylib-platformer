=========
TODO LIST
=========

- @BUG: Since dragging the window around blocks the events it receives, it actually results
		in breaking our game code as the player sometimes clips out of the screen and just
		teleports to some random value. 

- Always refactor for better architecture, but also get things working first.

- Title the game properly, complete missing main menu features.
- Figure out how to make opening menu + pause menu work with eachother. 

- Get some asset loading system to prepare for importing of character sprites / monster sprites /
  tiles, etc. (just make it work so we can put placeholders in).
- Once we get that sorted, find a good font to use throughout (should probably align with the
  artstyle-vision-thing we have for the game).
- If we do get a sense of direction for the artstyle, we can figure out what to do for the actual
  character sprites, tile map sprites, along with particle systems!

- Think about ways to improve collision detection rather than iterating through the entire array
  of tiles when in the game world. Maybe even switch to raycasting from the player to prevent
  flickering of states in the debug overlay.
- We got the camera system working but we should really be figuring out how we should format our
  world / levels / screens for the long term. We got things working using the screen dimensions,
  but we don't really know if those will continue working once we get the settings page running
  (which will allow different resolution scaling and stuff). Refer to the next section since it
  kinda relates to this one.
  
- Think about how the world editor would work (I had an idea of making it similiar to the
  geometry dash editor, but minus all the triggers, but we could do something like that!).
- Figure out some way we can store the world data to represent it within the game. That way we
  have save the "levels" in some file format somewhere in the game's data folder, and read from that.
- Conventionally, if we did store things in a screen-by-screen format (kinda like Animal Well), then
  we would be able to represent things easily in a simple array of integers, where 0's can be air spaces,
  1's are tiles, 2's are static spikes, etc.

- We can get our hotloader functionality put into the game, along with some configuration file
  that gets read from / written to to save user config options.
